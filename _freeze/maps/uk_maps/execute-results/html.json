{
  "hash": "879c0e8d55b4f970428b6ae27701f6d5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"UK Population\"\nsubtitle: \"My first foray into GIS work in R visualising the UK population\"\nauthor: \"Peter Gray\"\ncategories: [\"GIS\", \"Data Visualization\", \"R Programming\", \"2024\"]\ntags: [GIS, R, data visulation, ggplot2, Map work, tidyverse]\nimage: \"thumbnails/UK_population.png\"\nformat:\n  html:\n    toc: true\n    toc-depth: 5\n    code-link: true\n    code-fold: true\n    code-tools: false\n    code-summary: \"Show code\"\n    self-contained: true\n    theme: solar\neditor_options: \n  chunk_output_type: inline\nexecute: \n  freeze: true                                                  \n  cache: true                                                   \n  error: false\n  message: false\n  warning: false\n  eval: true\n---\n\n#### 1. R code\n![Thumbnail](thumbnails/UK_population.png)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif(!require(tidyverse)){install.packages(\"tidyverse\");library(tidyverse)}\nif(!require(ggplot2)){install.packages(\"ggplot2\");library(ggplot2)}\nif(!require(ggrepel)){install.packages(\"ggrepel\");library(ggrepel)}\nif(!require(sf)){install.packages(\"sf\");library(sf)}\nif(!require(eurostat)){install.packages(\"eurostat\");library(eurostat)}\nif(!require(classInt)){install.packages(\"classInt\");library(classInt)}\nif(!require(giscoR)){install.packages(\"giscoR\");library(giscoR)}\nif(!require(cartogram)){install.packages(\"cartogram\");library(cartogram)}\nif(!require(rayshader)){install.packages(\"rayshader\");library(rayshader)}\nif(!require(sysfonts)){install.packages(\"sysfonts\");library(sysfonts)}\nif(!require(showtext)){install.packages(\"showtext\");library(showtext)}\n\n# Define Fonts \n\n\nsysfonts::font_add_google(\"Roboto Mono\")\nshowtext::showtext_auto()\n\nget_polygon <- function() {\n  # st_area returns square meters so we get square km by dividing the result by 1000\n  df$area_sqkm <- as.numeric(sf::st_area(df) / 1000000)\n  \n  deu_polygon <- df |>\n    dplyr::mutate(pop_per_sqr_km = values / area_sqkm)\n  return(deu_polygon)\n}\n\ncustom_theme <- function() {\n  theme_minimal() +\n    theme(\n      text = element_text(size = 12),\n      axis.line = element_blank(),\n      axis.text.x = element_blank(),\n      axis.text.y = element_blank(),\n      axis.ticks = element_blank(),\n      axis.title.y = element_blank(),\n      legend.position =  \"bottom\",\n      legend.text = element_text(size = 30, color = \"grey20\"),\n      legend.title = element_text(size = 40, color = \"grey20\"),\n      legend.spacing.y = unit(0.25, \"cm\"),\n      legend.spacing.x = unit(0.25, \"cm\"),\n      panel.grid.major = element_blank(),\n      panel.grid.minor = element_blank(),\n      plot.margin = unit(\n        c(t = 0, r = 0, b = 0, l = 0), \"lines\"\n      ),\n      plot.background = element_rect(fill = \"#f5f5f2\", color = NA),\n      panel.background = element_rect(fill = \"#f5f5f2\", color = NA),\n      legend.background = element_rect(fill = \"#f5f5f2\", color = NA),\n      panel.border = element_blank(),\n    )\n}\n\n# colors\ncols <- rev(c(\n  \"#004225\", \"#2e8b57\",\n  \"#4682b4\", \"#5f9ea0\",\n  \"#20b2aa\", \"#008b8b\",\n  \"#b0e0e6\"\n))\n\n\n\nmake_polygon_map <- function(polygon, theme) {\n  p1 <-\n    ggplot(polygon) +\n    geom_sf(aes(fill = pop_per_sqr_km),\n            color = \"grey20\",\n            size = .1\n    ) +\n    scale_fill_gradientn(\n      name = \"\",\n      colours = cols,\n      breaks = breaks,\n      labels = round(breaks, 0),\n      limits = c(vmin, vmax)\n    ) +\n    guides(fill = guide_legend(\n      direction = \"horizontal\",\n      keyheight = unit(1.15, units = \"mm\"),\n      keywidth = unit(15, units = \"mm\"),\n      title.position = \"top\",\n      title.hjust = 0.5,\n      label.hjust = .5,\n      nrow = 1,\n      byrow = T,\n      reverse = F,\n      label.position = \"bottom\"\n    )) +\n    theme() +\n    labs(\n      y = \"\",\n      subtitle = \"\",\n      x = \"\",\n      title = \"\",\n      caption = \"\"\n    )\n  return(p1)\n}\n\n\n# Label Regions -----------------------------------------------------------\n\nlabel_regions <- function(coordinates) {\n  ggrepel::geom_text_repel(coordinates[1:5, ],\n                           mapping = aes(x = long, y = lat, label = NAME_LATN),\n                           colour = \"grey20\",\n                           fontface = \"bold\",\n                           size = 10,\n                           segment.colour = \"grey20\",\n                           segment.alpha = .9,\n                           segment.linetype = 3,\n                           segment.size = .25,\n                           nudge_x = .95,\n                           nudge_y = .15,\n                           direction = \"x\"\n  )\n}\n\n\n\n\n\nmake_point_map <- function(coordinates, labels) {\n  p2 <-\n    ggplot() +\n    geom_sf(\n      data = polygon,\n      fill = \"transparent\",\n      color = \"grey20\",\n      size = .1\n    ) +\n    geom_sf(\n      data = points,\n      mapping = aes(\n        size = pop_1000s,\n        geometry = geometry\n      ), color = cols[5],\n      alpha = .5\n    ) +\n    scale_size(\n      breaks = breaks,\n      range = c(1, 10),\n      labels = round(breaks, 0),\n      limits = c(vmin, vmax),\n      name = \"\"\n    ) +\n    guides(\n      color = \"none\",\n      size = guide_legend(\n        direction = \"vertical\",\n        title.position = \"top\",\n        title.hjust = 0.5,\n        label.hjust = 0,\n        nrow = 1,\n        byrow = F,\n        reverse = F,\n        label.position = \"bottom\"\n      )\n    ) +\n    custom_theme() +\n    labs(\n      y = \"\",\n      subtitle = \"\",\n      x = \"\",\n      title = \"\",\n      caption = \"\"\n    )\n  \n  # Add label regions only if labels = TRUE\n  if (labels) {\n    p2 <- p2 + label_regions(coordinates)\n  }\n  \n  return(p2)\n}\n\n\nget_cartogram <- function(df) {\n  deu_cart <- df %>% \n    sf::st_transform(crs = crsLAEA) |>\n    cartogram::cartogram_cont(\n      weight = \"pop_1000s\",\n      itermax = 5\n    ) |>\n    sf::st_transform(crs = crsLONGLAT)\n  return(deu_cart)\n}\n\n\nmake_cartogram <- function(cart, coordinates, labels) {\n  p3a <-\n    ggplot(cart) +\n    geom_sf(aes(fill = pop_1000s),\n            color = \"grey20\",\n            size = .1\n    ) +\n    scale_fill_gradientn(\n      name = \"\",\n      colours = cols,\n      breaks = breaks,\n      labels = round(breaks, 0),\n      limits = c(vmin, vmax)\n    ) +\n    guides(fill = guide_legend(\n      direction = \"horizontal\",\n      keyheight = unit(1.15, units = \"mm\"),\n      keywidth = unit(15, units = \"mm\"),\n      title.position = \"top\",\n      title.hjust = 0.5,\n      label.hjust = .5,\n      nrow = 1,\n      byrow = T,\n      reverse = F,\n      label.position = \"bottom\"\n    )) +\n    custom_theme() +\n    labs(\n      y = \"\",\n      subtitle = \"\",\n      x = \"\",\n      title = \"\",\n      caption = \"\"\n    )\n  \n  # Add label regions only if labels = TRUE\n  if (labels) {\n    p3a <- p3a + label_regions(coordinates)\n  }\n  \n  return(p3a)\n}\n\n\nget_ncontig_cartogram <- function(data) {\n  deu_ncart <- data %>% \n    sf::st_transform(crs = crsLAEA) %>% \n    cartogram::cartogram_ncont(\n      weight = \"pop_1000s\",\n      inplace = F\n    )\n  return(deu_ncart)\n}\n\n\n\n\n\nmake_ncontig_cartogram <- function(ncart, nuts, theme) {\n  p3b <-\n    ggplot(ncart) +\n    geom_sf(aes(fill = pop_1000s),\n            color = NA,\n            size = 0\n    ) +\n    geom_sf(\n      data = nuts, fill = \"transparent\",\n      color = \"grey20\", size = .1\n    ) +\n    scale_fill_gradientn(\n      name = \"\",\n      colours = cols,\n      breaks = breaks,\n      labels = round(breaks, 0),\n      limits = c(vmin, vmax)\n    ) +\n    guides(fill = guide_legend(\n      position = \"bottom\",\n      direction = \"horizontal\",\n      keyheight = unit(1.15, units = \"mm\"),\n      keywidth = unit(15, units = \"mm\"),\n      title.position = \"top\",\n      title.hjust = 0.5,\n      label.hjust = .5,\n      nrow = 1,\n      byrow = T,\n      reverse = F,\n      label.position = \"bottom\"\n    )) +\n    theme() +\n    labs(\n      y = \"\",\n      subtitle = \"\",\n      x = \"\",\n      title = \"\",\n      caption = \"\"\n    )\n  return(p3b)\n}\n\nget_dorling_cartogram <- function(data) {\n  dorling_cart <- data %>% \n    filter(!is.na(values)) %>% \n    st_transform(crs = crsLAEA) %>% \n    cartogram::cartogram_dorling(\n      weight = \"pop_1000s\"\n    )\n  return(dorling_cart)\n}\n\n\n\nmake_dorling_cartogram <- function(dorling_cart, theme) {\n  p3c <-\n    ggplot(dorling_cart) +\n    geom_sf(aes(fill = pop_1000s),\n            color = NA,\n            size = 0\n    ) +\n    scale_fill_gradientn(\n      name = \"\",\n      colours = cols,\n      breaks = breaks,\n      labels = round(breaks, 0),\n      limits = c(vmin, vmax)\n    ) +\n    guides(fill = guide_legend(\n      position = , \"bottom\",\n      direction = \"horizontal\",\n      keyheight = unit(1.15, units = \"mm\"),\n      keywidth = unit(15, units = \"mm\"),\n      title.position = \"top\",\n      title.hjust = 0.5,\n      label.hjust = .5,\n      nrow = 1,\n      byrow = T,\n      reverse = F,\n      label.position = \"bottom\"\n    )) +\n    theme() +\n    labs(\n      y = \"\",\n      subtitle = \"\",\n      x = \"\",\n      title = \"\",\n      caption = \"\"\n    )\n  return(p3c)\n}\n\n\n\nget_dot_density <- function(data) {\n  num_dots <- ceiling(dplyr::select(as.data.frame(data), pop_1000s)) %>% \n    filter(!is.na(pop_1000s))\n  dots <- map_df(\n    names(num_dots),\n    ~ sf::st_sample(df, size = num_dots[, .x], type = \"random\") %>% \n      sf::st_cast(\"POINT\") %>% \n      sf::st_coordinates() %>% \n      as_tibble() %>% \n      setNames(c(\"long\", \"lat\"))\n  )\n  return(dots)\n}\n\nmake_dot_density_map <- function(dots, nuts, labels, coordinates, theme) {\n  p4 <-\n    ggplot(dots) +\n    geom_sf(\n      data = nuts, fill = \"transparent\",\n      color = \"grey20\", size = .1\n    ) +\n    geom_point(\n      data = dots, aes(x = long, y = lat),\n      color = cols[5], size = .1, shape = 19, alpha = .2\n    ) +\n    theme() +\n    labs(\n      y = \"\",\n      subtitle = \"\",\n      x = \"\",\n      title = \"\",\n      caption = \"\"\n    )\n  \n  # Add label regions only if labels = TRUE\n  if (labels) {\n    p4 <- p4 + label_regions(coordinates)\n  }\n  \n  \n  return(p4)\n}\n\nget_grid <- function(country) {\n  \n  sf <- giscoR::gisco_get_countries(\n    year = \"2020\",\n    epsg = \"4326\",\n    resolution = \"3\",\n    country = country\n  )\n  \n  sf_transf <- sf |>\n    sf::st_transform(3575)\n  \n  grid <- sf_transf |>\n    sf::st_make_grid(cellsize = 50000) |>\n    sf::st_intersection(sf_transf) |>\n    st_cast(\"MULTIPOLYGON\") |>\n    sf::st_sf() |>\n    dplyr::mutate(id = row_number()) |>\n    sf::st_transform(crs = crsLONGLAT)\n  \n  \n  return(grid)\n}\n\n\nget_aggregated_grid <- function(grid, points) {\n  grid_final <- grid %>% \n    sf::st_join(points) %>% \n    dplyr::group_by(id) %>% \n    dplyr::summarise_at(\n      vars(pop_1000s),\n      list(pop_sum = sum)\n    ) %>% \n    drop_na(pop_sum) %>% \n    sf::st_sf() %>% \n    sf::st_transform(crs = crsLONGLAT)\n  return(grid_final)\n}\n\n\n\nmake_grid_map <- function(data, coordinates, labels, theme) {\n  p5 <-\n    ggplot(data) +\n    geom_sf(aes(fill = pop_sum),\n            color = \"grey20\",\n            size = .1\n    ) +\n    scale_fill_gradientn(\n      name = \"\",\n      colours = cols,\n      breaks = breaks,\n      labels = round(breaks, 0),\n      limits = c(vmin, vmax)\n    ) +\n    guides(fill = guide_legend(\n      direction = \"horizontal\",\n      keyheight = unit(1.15, units = \"mm\"),\n      keywidth = unit(15, units = \"mm\"),\n      title.position = \"top\",\n      title.hjust = 0.5,\n      label.hjust = .5,\n      nrow = 1,\n      byrow = T,\n      reverse = F,\n      label.position = \"bottom\"\n    )) +\n    theme() +\n    labs(\n      y = \"\",\n      subtitle = \"\",\n      x = \"\",\n      title = \"\",\n      caption = \"\"\n    )\n  return(p5)\n  \n  # Add label regions only if labels = TRUE\n  if (labels) {\n    p5 <- p5 + label_regions(coordinates)\n  }\n  \n}\n\n\nmake_raster_matrix <- function(data) {\n  pop_rast <- terra::rasterize(\n    data,\n    terra::rast(data, resolution = .01),\n    data$pop_sum\n  ) %>%  terra::na.omit()\n  \n  pop_mat <- rayshader::raster_to_matrix(pop_rast)\n  \n  return(pop_mat)\n}\n\n\n# Defining LongLat --------------------------------------------------------\n\n# longlat\ncrsLONGLAT <- \"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\"\n# Lambert\ncrsLAEA <-  \"+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs\"\n\ncountry = \"UK\"\n\n# Get  internal boundaries ---------------------------------\n\n\nnuts3 <- giscoR::gisco_get_nuts(\n  year = \"2021\",\n  epsg = \"4326\",\n  resolution = \"3\",\n  nuts_level = \"3\",\n  country = country\n)\n\n\n# Get the population data -------------------------------------------------\n\n\npop_df <- eurostat::get_eurostat(\"demo_r_pjangrp3\",\n                                 time_format = \"num\"\n) %>% \n  dplyr::filter(\n    sex == \"T\" &\n      unit == \"NR\" &\n      age == \"TOTAL\" &\n      grepl(\"UK\", geo) &\n      TIME_PERIOD == 2019 # No data available after that - likely due to\n  ) %>% \n  dplyr::select(geo, values) %>% \n  dplyr:: rename(NUTS_ID = geo) # rename for Merge\n\ndf <- nuts3 %>% \n  dplyr::left_join(pop_df, by = \"NUTS_ID\")\n\n\n# Draw the ploygons -------------------------------------------------------\n\npolygon <- get_polygon()\n\nvmin <- min(polygon$pop_per_sqr_km, na.rm = T)\nvmax <- max(polygon$pop_per_sqr_km, na.rm = T)\n\n\nbrk <- round(classIntervals(polygon$pop_per_sqr_km,\n                            n = 6,\n                            style = \"equal\")$brks, 0) %>% \n  head(-1) %>% \n  tail(-1) %>% \n  append(vmax)\n\nbreaks <- c(vmin, brk)\n\n\nmap1 <- make_polygon_map(polygon = polygon, theme = custom_theme) %>% \n  print()\n```\n\n::: {.cell-output-display}\n![](uk_maps_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggsave(\n  filename = paste0(country, \"_population_polygon.png\"),\n  width = 6, height = 8.5, dpi = 600, device = \"png\",\n  bg = \"#f5f5f2\", map1)\n\n\n# Draw the Points on the Map ----------------------------------------------\n\n\n# normalize population size\ndf$pop_1000s <- df$values / 1000\n\nvmin <- min(df$pop_1000s, na.rm = T)\nvmax <- max(df$pop_1000s, na.rm = T)\n\n# bins\nbrk <- round(classIntervals(df$pop_1000s,\n                            n = 6,\n                            style = \"equal\"\n)$brks, 0) %>% \n  head(-1) %>% \n  tail(-1) %>% \n  append(vmax)\n\n# breaks\nbreaks <- c(vmin, brk)\n\npoints <- df %>% \n  sf::st_centroid()\n\ncoords <- points %>% \n  dplyr::mutate(\n    long = unlist(map(geometry, 1)),\n    lat = unlist(map(geometry, 2))\n  ) %>% \n  dplyr::select(NAME_LATN, long, lat, pop_1000s) %>% \n  sf::st_drop_geometry() %>% \n  as.data.frame() %>% \n  dplyr::arrange(desc(pop_1000s))\n\n#Just want the capitals maps\n\ncities_data <- data.frame(\n  NAME_LATN = c(\"Cardiff\", \"London\", \"Edinburgh\", \"Belfast\"),\n  lat = c(51.4816, 51.5074, 55.9533, 54.5973),\n  long = c(-3.1791, -0.1278, -3.1883, -5.9301)\n)\n\n\n\n\nmap2 <- make_point_map(coordinates= cities_data, labels = T) %>% \n  print()\n```\n\n::: {.cell-output-display}\n![](uk_maps_files/figure-html/unnamed-chunk-1-2.png){width=672}\n:::\n\n```{.r .cell-code}\nggsave(\n  filename = paste0(country, \"_population_polygon_point.png\"),\n  width = 6, height = 8.5, dpi = 600, device = \"png\",\n  bg = \"white\", map2\n)\n\n\n# Cartogram ---------------------------------------------------------------\n\n\ncart <- get_cartogram(df)\n\nmap3a <- make_cartogram(cart, coordinates= cities_data, labels = T)\n\n\nggsave(\n  filename = paste0(country, \"_population_cartogram.png\"),\n  width = 6, height = 8.5, dpi = 600,\n  device = \"png\", bg = \"white\", map3a\n)\n\n\n# Non-contiguous Area Cartogram -------------------------------------------\n\nncart <- get_ncontig_cartogram(data = df)\n\nmap3b <- make_ncontig_cartogram(ncart = ncart, nuts = nuts3, theme = custom_theme())\n\n\n\n# Dorling -----------------------------------------------------------------\n\n\ndorling_cart <- get_dorling_cartogram(data = df)\n\n\nmap3c <- make_dorling_cartogram(dorling_cart = dorling_cart, theme = custom_theme)\n\n\nggsave(\n  filename = paste0(country, \"_population_dorling_cartogram.png\"),\n  width = 7, height = 7.5, dpi = 600, device = \"png\",\n  bg = \"white\", map3c)\n\n\n# Dot Density -------------------------------------------------------------\n\ndots <- get_dot_density(data = df)\n\n\nmap4 <- make_dot_density_map(dots = dots, nuts = nuts3, labels = T, coordinates = cities_data, theme = custom_theme)\n\n\nggsave(\n  filename = paste0(country, \"_population_dot_density.png\"),\n  width = 6, height = 8.5, dpi = 600, device = \"png\",\n  bg = \"white\", map4\n)\n\ngrid <- get_grid(country = country)\n\n\ngrid_final <- get_aggregated_grid(grid = grid, points = points)\n\n\nvmin <- min(grid_final$pop_sum, na.rm = T)\nvmax <- max(grid_final$pop_sum, na.rm = T)\n\nbrk <- round(classIntervals(grid_final$pop_sum,\n                            n = 6,\n                            style = \"equal\"\n)$brks, 0) %>% \n  head(-1) %>% \n  tail(-1) %>% \n  append(vmax)\n\nbreaks <- c(vmin, brk)\n\n\nmap5 <- make_grid_map(data = grid_final, coordinates = cities_data, labels = T, theme =custom_theme)\n\nggsave(\n  filename = paste0(country, \"_population_grid.png\"),\n  width = 6, height = 8.5, dpi = 600, device = \"png\",\n  bg = \"#f5f5f2\", map5\n)\n\npop_mat <- make_raster_matrix(data = grid_final)\n\nh <- 762\nw <- 916\n\ntexture <- grDevices::colorRampPalette(cols, bias = 3)(21)                      \n\n\npop_mat %>% \n  rayshader::height_shade(texture = texture) %>% \n  rayshader::plot_3d(\n    heightmap = pop_mat,\n    solid = F,\n    soliddepth = 0,\n    z = 20,\n    shadowdepth = 0,\n    shadow_darkness = .75,\n    windowsize = c(w, h),\n    phi = 65,\n    zoom = .6,\n    theta = -30,\n    background = \"white\"\n  )\n\n# rayshader::render_camera(phi = 35, zoom = .6, theta = -20)\n# \n# rayshader::render_highquality(\n#   filename = \"germany_population_3d.png\",\n#   samples = 500,\n#   preview = T,\n#   light = T,\n#   lightdirection = 0,\n#   lightcolor = \"white\",\n#   lightintensity = 1000,\n#   interactive = F,\n#   width = w, height = h\n# )\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}