{
  "hash": "353e2534a4a7ebd294689318d9449aa3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"TidyTuesday Week 26: US Petrol Prices\"\nsubtitle: \"This week we're exploring weekly US gas prices! The data comes from the U.S. Energy Information Administration (EIA), which publishes average retail gasoline and diesel prices each Monday. \"\nauthor: \"Peter Gray\"\ndate: \"2025-07-01\" \ncategories: [\"TidyTuesday\", \"Data Visualization\", \"Python Programming\" , \"Machine Learning\", \"2025\"]\ntags: [tidytuesday, R, data visulation, Python Programming, Pandas, Machine Learning]\nimage: \"thumbnails/TidyTues_Week26.png\"\nformat:\n  html:\n    toc: true\n    toc-depth: 5\n    code-link: true\n    code-fold: true\n    code-tools: false\n    code-summary: \"Show code\"\n    self-contained: true\neditor_options: \n  chunk_output_type: console\nexecute: \n  freeze: true                                                  \n  cache: true                                                   \n  error: false\n  message: false\n  warning: false\n  eval: true\n---\n\n#### 1. Python code\n\n::: {#f90f0afb .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport datetime as dt\nfrom sklearn.preprocessing import MinMaxScaler\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import LSTM, Dense, Dropout\nimport matplotlib.pyplot as plt\n\n# Load the data\nweekly_gas_prices = pd.read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-07-01/weekly_gas_prices.csv')\n\n# Filter and sort data for regular gasoline\npetrol = weekly_gas_prices[weekly_gas_prices[\"fuel\"] == \"gasoline\"]\npetrol = petrol[petrol[\"grade\"] == \"regular\"]\npetrol = petrol[petrol[\"formulation\"] == \"all\"]\npetrol['date'] = pd.to_datetime(petrol['date'])\npetrol = petrol.sort_values(by=\"date\")\n\n# --- Change for Monthly Aggregation ---\n# Create a 'month_year' column for aggregation\npetrol['month_year'] = petrol['date'].dt.to_period('M')\n\n\nmonthly_petrol = petrol.groupby('month_year')['price'].mean().reset_index()\nmonthly_petrol['month_year'] = monthly_petrol['month_year'].dt.to_timestamp() \n\n\nmonthly_petrol.rename(columns={'month_year': 'date'}, inplace=True)\nmonthly_petrol = monthly_petrol.sort_values(by='date')\n\n\nprices = monthly_petrol[['price']].values\n\nscaler = MinMaxScaler()\nscaled_prices = scaler.fit_transform(prices)\n\ndef create_sequences(data, seq_length):\n    X, y = [], []\n    for i in range(seq_length, len(data)):\n        X.append(data[i-seq_length:i])\n        y.append(data[i])\n    return np.array(X), np.array(y)\n\n\nsequence_length = 36  \nX, y = create_sequences(scaled_prices, sequence_length)\n\nsplit = int(0.8 * len(X))\nX_train, X_test = X[:split], X[split:]\ny_train, y_test = y[:split], y[split:]\n\nmodel = Sequential()\nmodel.add(LSTM(50, return_sequences=False, input_shape=(X_train.shape[1], 1)))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(1))\n\nmodel.compile(optimizer='adam', loss='mean_squared_error')\n\n\nhistory = model.fit(X_train, y_train, epochs=100, batch_size=4, validation_data=(X_test, y_test), verbose=0) \n\npredicted = model.predict(X_test)\npredicted_prices = scaler.inverse_transform(predicted)\nactual_prices = scaler.inverse_transform(y_test)\n\n# plt.figure(figsize=(12, 7))\n# test_dates = monthly_petrol['date'].iloc[split + sequence_length:].reset_index(drop=True)\n# \n# \n# # plt.plot(test_dates, actual_prices, label='Actual Monthly Price')\n# # plt.plot(test_dates, predicted_prices, label='Predicted Monthly Price')\n# # plt.title(\"LSTM Monthly Petrol Price Prediction\")\n# # plt.xlabel(\"Date\")\n# # plt.ylabel(\"Price\")\n# # plt.legend()\n# # plt.grid(True)\n# # plt.show()\n\n# Forecasting\nn_future_months = 24\nlast_sequence = X[-1]  \n\npredicted_sequence = []\ncurrent_seq = last_sequence.copy()\n\nfor _ in range(n_future_months):\n    pred = model.predict(current_seq[np.newaxis, :, :], verbose=0)[0, 0]\n    predicted_sequence.append(pred)\n\n  \n    current_seq = np.append(current_seq[1:], [[pred]], axis=0)\n\npredicted_future_prices = scaler.inverse_transform(np.array(predicted_sequence).reshape(-1, 1))\n\nlast_actual_date = monthly_petrol['date'].max()\n\nfuture_dates = pd.date_range(start=last_actual_date + pd.DateOffset(months=1), periods=n_future_months, freq='MS') # 'MS' for Month Start\n\nplt.figure(figsize=(12, 7))\n\n\nactual_recent_months = monthly_petrol.tail(36)\nplt.plot(actual_recent_months['date'], actual_recent_months['price'], label=\"Actual Monthly Price (Last 24 Months)\")\n\n\nplt.plot(future_dates, predicted_future_prices, label=f\"Forecast (Next {n_future_months} Months)\", color='red', linestyle='--')\n\nplt.title(f\"Monthly Regular Petrol Price Forecast for Next {n_future_months} Months\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Price\")\nplt.legend()\nplt.grid(False)\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\r1/3 ━━━━━━━━━━━━━━━━━━━━ 0s 222ms/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r3/3 ━━━━━━━━━━━━━━━━━━━━ 0s 105ms/step\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\r3/3 ━━━━━━━━━━━━━━━━━━━━ 0s 118ms/step\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](TidyTues_Week26_files/figure-html/cell-2-output-2.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "TidyTues_Week26_files"
    ],
    "filters": [],
    "includes": {}
  }
}